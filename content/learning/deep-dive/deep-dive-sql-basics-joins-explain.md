---
title: "SQL 기본: 조인/집계/인덱스가 먹는 조건 감각"
date: 2025-12-16
draft: false
topic: "Database"
tags: ["SQL", "Join", "Aggregation", "EXPLAIN", "Index"]
categories: ["Backend Deep Dive"]
description: "SQL 실행 순서와 조인/집계 성능 함정, 인덱스가 타는 조건을 감각으로 잡는 기본기"
module: "data-system"
quizzes:
  - question: "SQL의 논리적 실행 순서에서 WHERE 절은 언제 처리되는가?"
    options:
      - "SELECT 절 이후에 처리된다."
      - "ORDER BY 절 이후에 처리된다."
      - "FROM/JOIN 이후, GROUP BY 이전에 처리된다."
      - "LIMIT 절 직전에 처리된다."
    answer: 2
    explanation: "SQL 논리적 처리 순서: FROM → JOIN → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT. WHERE는 JOIN 직후에 행 필터링을 수행합니다."

  - question: "SQL 조인에서 성능이 느려지는 주요 원인이 아닌 것은?"
    options:
      - "조인 키에 인덱스가 없는 경우"
      - "SELECT 절에 많은 컬럼을 지정한 경우"
      - "조인 키의 데이터 타입이 불일치하여 인덱스를 사용할 수 없는 경우"
      - "WHERE 필터가 조인 후에 적용되어 중간 결과 집합이 불필요하게 큰 경우"
    answer: 1
    explanation: "SELECT 컬럼 개수는 디스크 I/O에는 영향을 줄 수 있지만, 조인 성능의 핵심 요소(인덱스 사용, 타입 일치, 필터 적용 시점)만큼 결정적이지 않습니다."

  - question: "'Sargable' 조건이란 무엇인가?"
    options:
      - "결과를 정렬(Sort)하는 조건"
      - "인덱스를 효율적으로 사용할 수 있는(Search ARGument ABLE) 조건"
      - "NULL 값을 포함하는 조건"
      - "복합 조인을 수행하는 조건"
    answer: 1
    explanation: "Sargable 조건은 `col = ?`, `col BETWEEN ? AND ?`처럼 인덱스 탐색이 가능한 형태입니다. `FUNCTION(col) = ?`처럼 컬럼에 함수를 적용하면 인덱스를 사용할 수 없게 됩니다."

  - question: "다음 중 인덱스를 타기 어려운(Non-Sargable) 조건은?"
    options:
      - "WHERE age = 30"
      - "WHERE created_at >= '2025-01-01' AND created_at < '2025-02-01'"
      - "WHERE user_id IN (1, 2, 3)"
      - "WHERE DATE(created_at) = '2025-01-15'"
    answer: 3
    explanation: "컬럼에 함수(`DATE(created_at)`)를 적용하면 MySQL은 모든 행에 대해 함수를 계산해야 하므로 인덱스를 사용할 수 없습니다. `created_at >= ? AND created_at < ?` 형태로 범위 조건을 사용해야 합니다."

  - question: "EXPLAIN 실행 계획에서 확인해야 할 핵심 포인트가 아닌 것은?"
    options:
      - "스캔 범위가 너무 큰지 (풀스캔 여부)"
      - "의도한 인덱스를 사용하고 있는지"
      - "정렬이나 임시 테이블 사용 여부"
      - "SELECT 절에 사용된 컬럼의 데이터 타입"
    answer: 3
    explanation: "EXPLAIN은 쿼리의 실행 방식(인덱스 사용, 스캔 범위, 정렬/임시 테이블)을 보여줍니다. 컬럼의 데이터 타입은 스키마 정의에서 확인하는 것이지 EXPLAIN 결과에서 직접 확인하는 핵심 요소는 아닙니다."
study_order: 201
---

## 이 글에서 얻는 것

- SQL을 “문법”이 아니라 **실행 관점(어떤 순서로 처리되는지)**으로 이해합니다.
- 조인/집계/정렬에서 성능이 터지는 지점을 미리 예상할 수 있습니다(왜 느린지 말로 설명 가능).
- 인덱스가 잘 타는 조건(sargable)과 안 타는 조건을 구분해, 다음 인덱스/튜닝 글을 훨씬 쉽게 따라갈 수 있습니다.

## 0) 왜 SQL ‘기본’이 중요한가

백엔드 성능 이슈의 상당수는 결국 SQL로 귀결됩니다.

- 애플리케이션은 느린 DB를 숨기기 어렵고,
- 캐시/비동기/샤딩 같은 고급 해법도 “기본 쿼리”가 망가지면 효과가 제한됩니다.

그래서 이 글은 “정답 쿼리”가 아니라, **느린 쿼리를 보고 원인을 좁히는 감각**을 만드는 데 집중합니다.

## 1) SQL 실행 순서(논리적 처리 순서)

보통 SELECT는 아래 순서로 처리된다고 생각하면 디버깅이 쉬워집니다.

1) `FROM` / `JOIN`(데이터 집합 만들기)  
2) `WHERE`(필터)  
3) `GROUP BY`(그룹)  
4) `HAVING`(그룹 필터)  
5) `SELECT`(컬럼 계산/프로젝션)  
6) `ORDER BY`(정렬)  
7) `LIMIT/OFFSET`(잘라내기)  

포인트:

- `WHERE`는 “행”을 줄이고, `HAVING`은 “그룹”을 줄입니다.
- `ORDER BY`는 보통 비쌉니다(정렬 비용). 인덱스로 정렬을 대체할 수 있으면 큰 이득입니다.

## 2) 조인: 무엇이 느려지는가

### 2-1) 조인의 비용은 “매칭”에서 온다

조인은 결국:

- A의 각 행에 대해,
- B에서 매칭되는 행을 찾는 과정입니다.

그래서 핵심은:

- 조인 키에 인덱스가 있는가?
- 어느 쪽이 드라이빙 테이블(먼저 읽는 쪽)인가?
- 필터(WHERE)가 얼마나 먼저 적용되는가?

### 2-2) 흔한 실수

- 필터를 늦게 적용해 조인 대상이 불필요하게 커짐
- 조인 키 타입 불일치(문자열 vs 숫자 등)로 인덱스가 무력화
- 1:N 조인 후 중복 행이 폭발해 `DISTINCT`/`GROUP BY`로 땜질(근본 문제 숨김)

## 3) 집계/정렬: 데이터가 커질수록 폭발한다

### 3-1) GROUP BY

`GROUP BY`는 “모아서 계산”이므로 데이터가 커지면 비용이 빠르게 증가합니다.

- 그룹 키가 많을수록(고유값 많을수록) 비용 증가
- 정렬/해시 기반 집계는 DB마다 다르지만, 공통적으로 “메모리/임시 공간”이 관여합니다

### 3-2) ORDER BY

정렬은 다음 중 하나입니다.

- 인덱스 순서를 그대로 이용(싸다)
- 별도의 정렬 수행(비싸다, 임시 공간/파일 정렬)

그래서 “인덱스가 ORDER BY를 커버할 수 있는지”는 튜닝에서 자주 보는 포인트입니다.

## 4) 인덱스가 ‘먹는’ 조건(sargable) 감각

인덱스를 타기 쉬운 조건:

- `col = ?`, `col IN (...)`
- `col >= ? AND col < ?`(범위)

인덱스를 망치기 쉬운 조건:

- 컬럼에 함수 적용: `DATE(col) = ...`
- 앞 와일드카드: `LIKE '%abc'`
- 타입 캐스팅/불일치로 인해 변환이 발생

예:

```sql
-- 인덱스를 못 타기 쉬움(컬럼에 함수)
WHERE DATE(created_at) = '2025-12-16'

-- 범위로 바꾸면 인덱스를 타기 쉬움
WHERE created_at >= '2025-12-16 00:00:00'
  AND created_at <  '2025-12-17 00:00:00'
```

## 5) EXPLAIN을 읽는 최소 루틴(맛보기)

다음 글에서 더 깊게 보겠지만, 최소한 아래는 습관으로 가져가면 좋습니다.

- scan 범위가 너무 큰가(풀스캔/범위 스캔)
- 어떤 인덱스를 썼는가(의도한 인덱스가 맞는가)
- 정렬/임시 테이블이 있는가(정렬 비용/메모리/디스크 사용)

중요한 건:

> EXPLAIN은 “정답”이 아니라, 가설을 세우게 해주는 힌트다

## 연습(추천)

- 같은 조건을 “함수 조건”과 “범위 조건”으로 각각 작성하고, EXPLAIN에서 인덱스 사용 여부가 어떻게 달라지는지 비교해보기
- 1:N 조인에서 결과가 폭발하는 케이스를 만들고, 필터를 조인 전에 적용했을 때 얼마나 줄어드는지 실험해보기
- ORDER BY가 있는 조회에서 “인덱스로 정렬이 대체되는 경우/안 되는 경우”를 케이스로 만들어 비교해보기
