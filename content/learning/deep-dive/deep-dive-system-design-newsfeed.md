---
title: "시스템 설계: 뉴스피드"
date: 2025-12-16
draft: false
topic: "System Design"
tags: ["System Design", "Newsfeed", "Fanout", "Cache"]
categories: ["Backend Deep Dive"]
description: "Fan-out on write/read, 캐시/타임라인 테이블 설계, 지연/일관성 트레이드오프 정리"
module: "architecture"
quizzes:
  - question: "뉴스피드 시스템에서 'Fan-out on Write' 전략의 주요 장점은?"
    options:
      - "쓰기 비용이 매우 낮다."
      - "피드 조회(읽기) 시 응답 속도가 매우 빠르다."
      - "데이터 일관성이 항상 완벽하게 보장된다."
      - "유명인(팔로워가 많은 사용자)에게 특히 유리하다."
    answer: 1
    explanation: "Fan-out on Write는 게시물 작성 시 팔로워들의 타임라인에 미리 데이터를 복사해 두므로, 피드 조회 시에는 단순 조회만 하면 되어 응답이 매우 빠릅니다."

  - question: "팔로워가 수백만 명인 유명인(Celebrity)에게 'Fan-out on Write'를 그대로 적용했을 때 발생하는 문제점은?"
    options:
      - "피드 조회가 느려진다."
      - "유명인이 글을 올릴 때마다 수백만 건의 쓰기 작업이 발생하여 쓰기 폭발 및 백로그가 쌓인다."
      - "팔로워 정보가 유실된다."
      - "읽기 경로의 캐시가 무효화된다."
    answer: 1
    explanation: "팔로워 수만큼 타임라인에 기록해야 하므로, 거대 팔로워를 가진 유명인의 게시물은 시스템에 큰 부하를 주고 처리 지연을 유발합니다. 이를 위해 하이브리드 전략(일반 유저는 Fan-out on Write, 유명인은 Fan-out on Read)을 사용합니다."

  - question: "뉴스피드 읽기 경로에서 '페이징(Pagination)'을 offset 방식이 아닌 커서/키셋(Cursor/Keyset) 방식을 사용해야 하는 이유는?"
    options:
      - "구현이 더 간단하기 때문"
      - "실시간으로 데이터가 추가/삭제되는 피드에서 offset은 중복 또는 누락을 발생시킬 수 있기 때문"
      - "SQL 표준에서 offset을 사용하지 못하게 막기 때문"
      - "캐시를 사용할 수 없기 때문"
    answer: 1
    explanation: "피드는 지속적으로 새 게시물이 추가됩니다. offset 방식은 페이지 이동 중 데이터 추가 시 같은 게시물을 다시 보거나, 놓칠 수 있습니다. 커서 기반(예: `created_at`, `post_id`)은 이 문제를 해결합니다."

  - question: "뉴스피드에서 좋아요/댓글 '카운터'를 매번 DB JOIN으로 조회하는 것이 비효율적인 이유와 일반적인 해결책은?"
    options:
      - "JOIN 문법이 복잡해서 / 비정규화된 테이블을 사용"
      - "읽기 비용이 너무 높아서 / 카운터를 비동기(이벤트 기반)로 집계하고 Redis 캐시에서 제공"
      - "데이터 정확도가 낮아서 / DB 트랜잭션을 항상 사용"
      - "쓰기 잠금이 발생해서 / 테이블 샤딩"
    answer: 1
    explanation: "피드 조회마다 좋아요 수를 COUNT하거나 JOIN하면 DB 부하가 폭발합니다. 좋아요 이벤트를 Kafka 등으로 받아 비동기로 집계하고, Redis에 최신 카운터를 캐싱하여 제공하는 것이 일반적입니다."

  - question: "피드에서 특정 사용자를 '차단(Block)'하거나 '뮤트(Mute)'해야 할 때, 가장 적절한 처리 위치는?"
    options:
      - "Fan-out on Write 단계에서 차단된 사용자에게는 데이터를 아예 쓰지 않는다. (단독 해법)"
      - "읽기(머지) 단계에서 차단한 author의 게시물을 필터링하거나, 데이터 정리 정책을 병행한다."
      - "클라이언트(앱)에서 필터링한다."
      - "DB에서 해당 게시물을 물리적으로 삭제한다."
    answer: 1
    explanation: "Fan-out 데이터를 완벽하게 소급 삭제하는 것은 비용이 큽니다. 읽기 단계에서 차단한 author를 필터링하는 것이 더 유연하며, 필요시 백그라운드로 Fan-out 데이터를 정리하는 정책을 병행합니다."
study_order: 457
---

## 이 글에서 얻는 것

- 뉴스피드를 “테이블 하나”가 아니라, **쓰기(팬아웃)/읽기(머지)/캐시/카운터/정합성** 문제로 분해할 수 있습니다.
- Fan-out on write vs read의 트레이드오프를 이해하고, 팔로워 규모(celebrity)까지 고려한 하이브리드 설계를 만들 수 있습니다.
- 운영에서 자주 터지는 것(핫 키, 백필, 카운터 정합성, 삭제/차단)을 포함해 현실적인 설계 기준을 정리할 수 있습니다.

## 0) 문제 정의: 어떤 피드인가

뉴스피드는 크게 두 타입으로 갈립니다.

- **시간순(chronological)**: 최신 게시물이 위(설계가 비교적 단순)
- **랭킹/추천(ranked)**: 점수 기반(후보 생성/랭킹/캐시 전략이 더 복잡)

이 글은 “팔로우 기반 + 최신순”을 기본으로 설명하고,
랭킹 피드로 확장될 때 어떤 점이 달라지는지까지 힌트를 남깁니다.

## 1) 핵심 요구사항(최소)

- 사용자는 다른 사용자를 팔로우한다
- 사용자는 게시물을 올린다
- 사용자는 내 피드를 조회한다(최근 N개)
- 피드에는 좋아요/댓글 수 같은 카운터가 보인다(약간의 지연 허용 가능)

핵심 트레이드오프:

- 지연(latency) vs 비용(cost) vs 일관성(consistency)

## 2) 두 가지 큰 전략: Fan-out on write vs on read

### 2-1) Fan-out on write(쓰기 시 복사)

게시물이 생성될 때, 팔로워들의 타임라인에 “미리” 넣어 둡니다.

장점:

- 읽기(피드 조회)가 빠릅니다(단순 조회/캐시 히트)

단점:

- 쓰기 비용이 큽니다(팔로워 수만큼 기록/캐시)
- 유명인(수백만 팔로워)이 글을 올리면 쓰기가 폭발합니다(핫 키/백로그)

### 2-2) Fan-out on read(읽기 시 머지)

피드를 읽을 때 팔로우한 사람들의 게시물을 모아 정렬/머지합니다.

장점:

- 쓰기 비용이 작고, 실시간성이 좋습니다

단점:

- 읽기 비용이 큽니다(조인/정렬/머지)
- 캐시/프리컴퓨팅 없이는 고QPS에서 버티기 어렵습니다

## 3) 현실적 답: 하이브리드(팔로워 규모에 따라 분리)

대부분의 시스템은 “모두 write” 또는 “모두 read”로 끝나지 않습니다.

예:

- 일반 유저(팔로워 적음): fan-out on write
- 유명인(팔로워 많음): fan-out on read 또는 별도 경로(머지)

이렇게 하면:

- 일반 유저는 읽기가 빠르고
- 유명인은 쓰기 폭발을 피할 수 있습니다

## 4) 데이터 모델(개념)

### 4-1) 관계/게시물

- `follow(follower_id, followee_id)`
- `post(post_id, author_id, created_at, ...)`

### 4-2) 타임라인(팬아웃 결과)

팬아웃 on write를 쓰면 보통 “사용자별 타임라인”을 둡니다.

- `user_timeline(user_id, created_at, post_id, author_id, ...)`

인덱스는 보통:

- `(user_id, created_at desc, post_id desc)` 형태(키셋 페이징에 유리)

## 5) 쓰기 경로(게시물 생성)

기본 흐름:

1) 게시물 저장  
2) 팬아웃 작업을 큐/스트림에 넣음(비동기)  
3) 워커가 팔로워 목록을 조회해 타임라인에 적재(배치/청크)  

왜 비동기인가?

- 팔로워 수가 많으면 요청이 타임아웃납니다
- 백로그/재시도/모니터링이 가능한 구조가 필요합니다

유명인 처리:

- 팔로워가 많은 author는 “팬아웃을 하지 않고” author의 게시물 목록만 저장
- 읽기 시 “내 타임라인 + 유명인 게시물”을 머지

## 6) 읽기 경로(피드 조회): 캐시 + 백필(backfill)

가장 흔한 패턴:

- Redis에 최근 N개를 캐시(정렬된 set/list)
- 캐시에 부족하면 DB에서 백필(backfill)로 채움

페이징은 offset보다 “커서/키셋”이 안정적입니다.

- `(created_at, post_id)`를 커서로 사용하면 중복/누락이 줄어듭니다.

## 7) 좋아요/댓글 카운터: 실시간보다 “확장”이 우선

카운터를 매번 DB join으로 가져오면 읽기 비용이 큽니다.
보통은:

- 이벤트로 카운터를 집계(비동기)
- Redis/캐시로 최신 카운터 제공
- 최종값은 배치로 DB에 반영(또는 CQRS)

정합성:

- 약간의 지연은 허용하는 대신, “음수/폭발” 같은 오류는 없게(멱등/중복 방지) 설계합니다.

## 8) 운영에서 꼭 나오는 이슈

- 핫 키: 유명인/핫 유저의 타임라인 키가 폭주
- 삭제/차단: 피드에서 특정 author를 숨겨야 함(차단/뮤트) → 읽기 머지 단계에서 필터링하거나, 팬아웃 데이터 정리 정책 필요
- 백로그: 팬아웃 큐가 쌓이면 “피드가 늦게 갱신”됨 → 지연 지표/알람이 필요

## 9) 랭킹 피드로 확장되면 달라지는 것(힌트)

랭킹 피드는 보통:

- 후보 생성(candidate generation)과
- 점수 계산(ranking)을 분리하고,
- 캐시/프리컴퓨팅으로 비용을 통제합니다.

즉, “단순 정렬” 문제에서 “추천 시스템/캐시 전략” 문제로 확장됩니다.

## 연습(추천)

- 팔로워 100명/게시물 1일 1개/피드 조회 1일 10회를 가정하고, fan-out on write vs read의 비용을 대략 계산해보기
- 유명인(팔로워 1,000,000명) 케이스에서 팬아웃을 하면 무엇이 병목이 되는지, 하이브리드로 어떻게 피할지 설계해보기
- Redis 캐시 + DB 백필 구조에서 “중복/누락 없이” 페이징하는 커서 설계를 작성해보기
