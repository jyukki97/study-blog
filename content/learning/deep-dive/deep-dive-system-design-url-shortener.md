---
title: "시스템 설계: URL Shortener"
date: 2025-12-16
draft: false
topic: "System Design"
tags: ["System Design", "URL Shortener", "Hash", "Cache", "DB"]
categories: ["Backend Deep Dive"]
description: "Key 생성, 충돌 방지, 캐시/DB 설계, 확장성·가용성 고려사항 정리"
module: "architecture"
quizzes:
  - question: "URL Shortener에서 짧은 코드를 원래 URL로 리다이렉트하는 '읽기 경로'의 지연(Latency)을 낮추기 위한 가장 효과적인 방법은?"
    options:
      - "데이터베이스 샤딩을 적용한다."
      - "코드의 길이를 최대한 짧게 만든다."
      - "Redis와 같은 인메모리 캐시를 최우선으로 조회하고, 캐시 미스 시에만 DB를 조회한다."
      - "301 대신 302 리다이렉트를 사용한다."
    answer: 2
    explanation: "리다이렉트 경로는 QPS가 매우 높으므로, 모든 요청이 DB를 조회하면 병목이 됩니다. 인메모리 캐시(Redis)를 앞단에 두어 대부분의 요청을 캐시에서 처리하는 것이 핵심입니다."

  - question: "짧은 코드(Short Key)를 생성하는 전략 중, 'DB의 Auto Increment ID를 Base62로 인코딩'하는 방법의 단점은?"
    options:
      - "구현이 매우 복잡하다."
      - "코드 충돌(Collision)이 발생할 확률이 높다."
      - "코드가 순차적으로 증가하여 추측(Guessing)이 가능해지므로, 크롤링/스캐닝 공격에 취약할 수 있다."
      - "코드 길이를 예측할 수 없다."
    answer: 2
    explanation: "ID 기반 생성은 충돌이 없고 빠르지만, 코드가 예측 가능해져 악의적인 사용자가 URL을 순서대로 스캔할 수 있습니다. 이를 막기 위해 레이트 리밋이나 봇 탐지가 필요합니다."

  - question: "'존재하지 않는 코드'에 대한 요청이 폭발적으로 증가할 때 DB 부하를 막기 위한 효과적인 캐시 전략은?"
    options:
      - "캐시 TTL을 0으로 설정한다."
      - "Negative Caching (존재하지 않음을 나타내는 값도 짧은 TTL로 캐싱)"
      - "모든 코드를 미리 생성해 캐시에 적재한다."
      - "캐시를 사용하지 않고 DB만 조회한다."
    answer: 1
    explanation: "Negative Caching은 '없는 데이터'에 대해서도 짧은 시간 동안 '없음'이라는 결과를 캐싱하여, 동일한 잘못된 요청이 반복적으로 DB를 때리는 것을 방지합니다."

  - question: "클릭 수와 같은 '통계(Analytics)' 데이터를 동기적으로 DB에 업데이트하는 것이 위험한 이유는?"
    options:
      - "데이터가 부정확해지기 때문"
      - "트래픽이 많으면 DB 쓰기 폭발 및 리다이렉트 지연으로 이어지기 때문"
      - "법적으로 허용되지 않기 때문"
      - "캐시 무효화가 불가능해지기 때문"
    answer: 1
    explanation: "인기 URL은 초당 수만 번 클릭될 수 있습니다. 매 클릭마다 DB UPDATE를 실행하면 DB 병목이 생기고 리다이렉트 응답 시간이 늘어납니다. 이벤트를 큐(Kafka 등)에 발행하고 비동기로 집계하는 것이 일반적입니다."

  - question: "URL 단축 서비스의 주요 보안 위협으로, 악성 사이트로 리다이렉트되는 URL이 생성되는 것을 방지하기 위한 대책이 아닌 것은?"
    options:
      - "등록 시 URL을 악성 여부와 비교하여 차단 목록(Blocklist)을 조회한다."
      - "사용자 신고 및 관리자 차단 프로세스를 구축한다."
      - "레이트 리밋을 적용하여 대량 URL 생성을 막는다."
      - "짧은 URL 코드의 길이를 늘린다."
    answer: 3
    explanation: "코드 길이를 늘리는 것은 충돌 가능성을 줄이는 효과는 있지만, 악성 리다이렉트/피싱 문제와는 직접적인 관련이 없습니다. 차단 목록 조회, 신고 시스템, 도메인 화이트리스트 등이 보안 대책입니다."
study_order: 455
---

## 이 글에서 얻는 것

- URL Shortener의 핵심 요구(낮은 지연/고가용성/키 생성/중복·충돌)를 설계 요소로 분해할 수 있습니다.
- “읽기 경로(redirect)”와 “쓰기 경로(단축 생성)”를 각각 어떤 저장소/캐시 전략으로 풀어야 하는지 기준이 생깁니다.
- 운영에서 터지는 문제(핫 키, 스탬피드, 악성 트래픽, 통계 수집 비용)를 미리 고려한 설계를 만들 수 있습니다.

## 0) 문제 정의: 무엇을 만들 건가

URL Shortener는 크게 두 가지 기능이 핵심입니다.

1) 긴 URL을 짧은 코드로 바꿔준다(생성)  
2) 짧은 코드를 원래 URL로 리다이렉트한다(조회/redirect)  

여기에 옵션으로 보통 아래가 붙습니다.

- 커스텀 별칭(custom alias)
- 만료(expire)
- 클릭 통계/분석(analytics)
- 악성/스팸 방지(보안/레이트리밋)

## 1) API 설계(최소)

### 1-1) 단축 생성

- `POST /api/shorten`
  - body: `{ longUrl, customAlias?, expireAt? }`
  - response: `{ code, shortUrl, expireAt? }`

### 1-2) 리다이렉트

- `GET /{code}` → `301` 또는 `302`로 `Location: <longUrl>`

실무 감각:

- 영구 리다이렉트면 301, 실험/단기면 302를 쓰는 경우가 많습니다(캐시/SEO 영향 포함).

## 2) 데이터 모델(최소)

핵심은 “code가 유니크”이고, 조회가 빠른 형태입니다.

- `url_mapping`
  - `code`(PK 또는 unique)
  - `long_url`
  - `created_at`
  - `expire_at`(nullable)
  - `owner_id`(nullable, 커스텀/관리 기능이 있으면)

통계는 별 테이블/별 스토리지로 분리하는 편이 좋습니다(쓰기 폭발을 막기 위해).

## 3) Key(코드) 생성 전략: 설계의 중심

코드 생성은 크게 3가지 계열로 나뉩니다.

### 3-1) 증가하는 ID → Base62 인코딩(가장 단순/효율적)

- DB 시퀀스/auto increment 또는 Snowflake로 숫자 ID 생성
- 이를 Base62로 바꿔 짧은 문자열로 표현

장점:

- 충돌이 사실상 없음, 생성이 빠름
- 길이가 예측 가능(트래픽이 늘어도 점진적으로 늘어남)

단점/주의:

- 코드가 “추측 가능”해서 크롤링/스캔 위험이 커질 수 있음(보안/레이트리밋 필요)
- 멀티 리전/분산에서 ID 생성 전략을 잘 잡아야 함(Snowflake 등)

### 3-2) 랜덤/UUID/해시 기반(추측 어려움)

장점:

- 추측이 어렵고, 외부 노출에 상대적으로 안전

단점:

- 충돌 확률이 0이 아니므로 “충돌 처리(재시도/유니크 제약)”가 필요
- 코드 길이가 길어지기 쉬움

### 3-3) 커스텀 별칭

사용자가 원하는 코드(`my-page`)를 지정합니다.

- 반드시 unique 제약이 필요
- 금칙어/길이 제한/예약어(관리자 경로 등) 정책이 필요

## 4) 읽기 경로(redirect) 설계: 캐시가 승패를 가른다

리다이렉트는 보통 QPS가 매우 높습니다. 그래서 기본은:

1) Redis/메모리 캐시 조회  
2) miss면 DB 조회  
3) 캐시에 적재(TTL 포함)  

핵심 포인트:

- 캐시 키는 `code` 그대로 또는 `url:v1:{code}` 형태로 안정적으로
- 만료가 있는 경우 TTL을 `expire_at`과 정합 맞추기
- 존재하지 않는 code에 대한 요청이 폭주할 수 있으니 “없는 것 캐싱(negative caching)”을 고려
- 핫 키 만료 순간 스탬피드가 날 수 있어 TTL 지터/싱글플라이트 같은 완화책을 고려

## 5) 쓰기 경로(단축 생성) 설계: 충돌/중복을 다룬다

쓰기 경로는 상대적으로 QPS가 낮지만, 정합성이 중요합니다.

- code 생성 → insert 시도 → unique 충돌이면 재시도
- 커스텀 별칭은 “먼저 조회”로만 막지 말고, DB unique 제약으로 최종 보장
- 같은 longUrl을 여러 번 줄였을 때 “항상 같은 코드”를 주는지(중복 제거) 정책을 정해야 합니다  
  - 중복 제거를 원하면 longUrl 해시(정규화 포함)를 별 컬럼로 두고 unique 처리하는 방식도 가능  
  - 대신 사용자별/만료별 정책이 복잡해집니다

## 6) 확장성/가용성: 어디가 병목이 되나

- 읽기 병목: 캐시 hit 비율, Redis/QPS, DB read replica
- 쓰기 병목: 코드 생성기(ID 생성), DB unique insert 경합
- 샤딩: `code`(또는 해시된 code)로 샤딩하면 분산이 쉽습니다

가용성:

- 캐시 장애 시 DB로 우회(지연은 증가하지만 서비스 유지)
- DB 장애 시 “단축 생성은 제한”하고 “리다이렉트만 유지” 같은 모드 전환(Graceful Degradation)도 고려

## 7) 통계(Analytics): 동기 쓰기는 피한다

클릭 통계를 동기 DB 업데이트로 쌓으면 쓰기가 폭발합니다.
보통은 “이벤트로 남기고 비동기로 집계”합니다.

- redirect 시 `click_event`를 Kafka/Queue에 발행
- 배치/스트리밍으로 집계 테이블에 반영

## 8) 보안/운영에서 자주 터지는 것

- 악성 리다이렉트/피싱: 도메인 차단/검증, 신고/차단 프로세스
- 코드 스캐닝: 레이트 리밋, 봇 탐지, 추측 가능한 코드 전략이면 특히 중요
- Open redirect 남용: 내부 도메인 화이트리스트 정책이 필요한 경우도 있음(서비스 성격에 따라)

## 연습(추천)

- Base62 인코더를 만들고, “증가 ID → code”로 단축 생성/리다이렉트를 구현해보기
- Redis 캐시를 붙이고 hit/miss 로그로 실제 효과를 확인해보기(negative caching 포함)
- 클릭 이벤트를 큐로 발행하고 “시간당 클릭 수”를 비동기 집계하는 흐름을 만들어보기
