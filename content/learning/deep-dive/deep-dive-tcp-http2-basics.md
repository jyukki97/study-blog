---
title: "네트워크 기초: TCP 핸드셰이크와 HTTP/2"
date: 2025-12-16
draft: false
topic: "Network"
tags: ["TCP", "HTTP2", "Handshake", "Multiplexing"]
categories: ["Backend Deep Dive"]
description: "TCP 3-way, 흐름/혼잡 제어, HTTP/2 멀티플렉싱·HPACK·헤더 압축 핵심"
module: "foundation"
quizzes:
  - question: "TCP 3-Way Handshake 과정에서 클라이언트가 서버에 연결 요청을 보내기 위해 처음 전송하는 패킷(Flag)은?"
    options:
      - "ACK"
      - "SYN"
      - "FIN"
      - "RST"
    answer: 1
    explanation: "클라이언트는 연결 수립을 위해 SYN(Synchronize) 패킷을 보내고, 서버는 SYN-ACK로 응답하며, 마지막으로 클라이언트가 ACK를 보내 연결이 성립됩니다."

  - question: "TCP 연결 종료 후, 마지막 ACK가 유실될 경우를 대비하여 일정 시간 동안 소켓을 닫지 않고 기다리는 상태는?"
    options:
      - "ESTABLISHED"
      - "CLOSE_WAIT"
      - "TIME_WAIT"
      - "SYN_SENT"
    answer: 2
    explanation: "TIME_WAIT는 먼저 연결 종료를 요청한 쪽(Active Closer)에서 발생하며, 지연된 패킷이 뒤늦게 도착하거나 마지막 ACK 재전송을 위해 필요하지만 너무 많으면 포트 고갈의 원인이 되기도 합니다."

  - question: "HTTP/1.1의 문제점 중 하나로, 하나의 연결에서 요청을 순차적으로 처리해야 해서 앞선 요청이 늦어지면 뒤의 요청도 막히는 현상은?"
    options:
      - "Head-of-Line (HOL) Blocking"
      - "Deadlock"
      - "Race Condition"
      - "Throttling"
    answer: 0
    explanation: "HTTP/1.1의 파이프라이닝은 불완전하여 실무에서 잘 쓰이지 않았고, 결국 요청을 순서대로 처리해야 하는 HOL Blocking 문제가 있었습니다. HTTP/2는 멀티플렉싱으로 이를 해결했습니다."

  - question: "HTTP/2의 핵심 기능인 'Multiplexing(멀티플렉싱)'의 특징은?"
    options:
      - "여러 개의 TCP 연결을 맺어 데이터를 전송한다."
      - "하나의 TCP 연결 안에서 여러 개의 스트림(Stream)을 사용하여 요청과 응답을 뒤섞어서(Parallel) 동시에 전송한다."
      - "헤더를 압축하지 않고 전송한다."
      - "UDP 프로토콜을 사용한다."
    answer: 1
    explanation: "멀티플렉싱 덕분에 HTTP/1.1처럼 여러 개의 TCP 연결(도메인 샤딩 등)을 맺을 필요가 줄어들었고, 하나의 연결로도 높은 병렬성을 가집니다."

  - question: "TCP의 '흐름 제어(Flow Control)'와 '혼잡 제어(Congestion Control)'의 차이점은?"
    options:
      - "차이가 없다."
      - "흐름 제어는 송신 측의 속도를 조절하고, 혼잡 제어는 수신 측의 속도를 조절한다."
      - "흐름 제어는 수신 측의 처리 능력(버퍼)을 고려하여 조절하고, 혼잡 제어는 네트워크 망의 혼잡 상태를 고려하여 조절한다."
      - "흐름 제어는 UDP에서 사용하고, 혼잡 제어는 TCP에서 사용한다."
    answer: 2
    explanation: "흐름 제어는 '상대방이 못 받을까봐(Window Size)', 혼잡 제어는 '중간 네트워크가 막힐까봐(Slow Start 등)' 속도를 조절하는 메커니즘입니다."

  - question: "HTTP/2에서 중복되는 헤더(Header)의 크기를 줄이기 위해 사용하는 압축 기술은?"
    options:
      - "GZIP"
      - "Brotli"
      - "HPACK"
      - "LZ4"
    answer: 2
    explanation: "HPACK은 정적/동적 테이블을 사용하여 헤더 필드를 인덱싱하고 중복을 제거하여 헤더 오버헤드를 획기적으로 줄여줍니다."
study_order: 51
---

## 이 글에서 얻는 것

- TCP가 “연결”을 만들고 끊는 과정(Handshake/Close/TIME_WAIT)을 이해하고, 타임아웃/연결 재사용 이슈를 설명할 수 있습니다.
- 흐름 제어(Flow)와 혼잡 제어(Congestion)를 구분해서, “왜 느린지”를 RTT/대역폭/패킷 손실 관점으로 생각할 수 있습니다.
- HTTP/2의 핵심(멀티플렉싱/헤더 압축/스트림)을 알고, HTTP/1.1 대비 어떤 문제가 줄고 어떤 문제는 남는지 판단할 수 있습니다.
- 프로덕션에서 HTTP/2가 “켜져 있는지/어디서 종료되는지”를 확인하는 기본 점검 포인트를 정리합니다.

## 1) TCP: 연결을 만든다는 것의 의미

HTTP 요청 하나도 결국 TCP 위에서 오갑니다. TCP에서 핵심은 “신뢰성”을 위해 연결 상태를 유지하고,
순서 보장/재전송/흐름 제어/혼잡 제어를 수행한다는 점입니다.

### 3-way Handshake(연결 수립)

1) SYN (클라이언트 → 서버)  
2) SYN-ACK (서버 → 클라이언트)  
3) ACK (클라이언트 → 서버)  

핵심 감각:

- RTT(왕복 지연)가 큰 환경일수록 “연결을 새로 만드는 비용”이 커집니다. → 그래서 Keep-Alive/커넥션 풀/재사용이 중요합니다.

### 4-way Close와 TIME_WAIT

연결 종료는 양방향이므로 보통 4번의 메시지가 오갑니다. 그리고 종료 후 한쪽은 TIME_WAIT에 머뭅니다.

- 목적: 지연된 패킷이 다음 연결에 섞이는 것을 방지, 마지막 ACK 유실 대비
- 증상: 단시간에 많은 단기 연결을 만들면 TIME_WAIT가 늘어나고 포트 고갈/연결 실패로 이어질 수 있습니다.

## 2) 흐름 제어 vs 혼잡 제어: “상대가 못 받는 문제” vs “네트워크가 못 버티는 문제”

### 흐름 제어(Flow control)

수신 측이 “내가 지금 이만큼까지는 받을 수 있어”를 윈도(window)로 알려서, 버퍼 오버플로우를 막습니다.

### 혼잡 제어(Congestion control)

네트워크 중간(라우터/망)이 붐비면 패킷 손실/지연이 증가합니다. 이때 송신 측이 전송량을 조절합니다.

감각적으로는:

- RTT가 크거나 손실이 있는 환경에서는 처리량이 급격히 떨어질 수 있습니다.
- “서버가 빠른데도 느리다”면 애플리케이션보다 네트워크/혼잡/재전송이 원인일 수 있습니다.

## 3) HTTP/2: 한 커넥션으로 여러 요청을 동시에

HTTP/1.1의 대표적인 병목은 “한 커넥션에서 요청/응답이 줄줄이 막히는” 구조였습니다(파이프라이닝 한계, 커넥션 증가).
HTTP/2는 한 TCP 커넥션 안에 **여러 스트림(Stream)** 을 두고 **멀티플렉싱**합니다.

핵심 특징:

- **멀티플렉싱**: 한 커넥션에서 여러 요청/응답을 동시에 흘려 보냄 → 커넥션 수 감소, 헤더 반복 감소
- **HPACK 헤더 압축**: 헤더 크기를 줄여 오버헤드 감소
- **서버 푸시**: 한때 기대가 컸지만 운용 복잡도 때문에 현재는 보수적으로 접근(대부분 비권장)

주의: HTTP/2가 “모든 HOL Blocking을 없애는 것”은 아닙니다. TCP 레벨에서 패킷 손실이 나면 같은 커넥션 안의 스트림들이 영향을 받을 수 있습니다.
(이 문제를 더 줄이려는 접근이 HTTP/3(QUIC)입니다.)

## 4) 실무 점검 포인트(최소)

- 커넥션 재사용이 되는가: Keep-Alive/커넥션 풀/프록시 설정
- HTTP/2 협상이 되는가: TLS + ALPN(대부분의 브라우저/프로덕션 환경)
- 어디서 h2가 종료되는가: CDN/LB/프록시가 h2를 받고, 백엔드로는 h1.1로 내려보내는 경우가 흔합니다.
- 다운그레이드 시 영향: h2 → h1.1로 떨어지면 커넥션 수/지연/헤더 오버헤드가 증가할 수 있습니다.

## 연습(추천)

- `curl -v --http2 https://example.com`로 ALPN 협상과 프로토콜을 확인해보기
- 같은 엔드포인트에 병렬 요청을 날려서 h1.1(다중 커넥션) vs h2(단일 커넥션)의 차이를 체감해보기
