---
title: "시스템 설계: 파일 업로드와 서빙 (S3+CDN)"
date: 2025-12-16
draft: false
topic: "System Design"
tags: ["System Design", "S3", "CDN", "파일업로드"]
categories: ["Backend Deep Dive"]
description: "Presigned URL, 멀티파트 업로드, CDN 캐싱 전략으로 파일을 안전하게 업로드/서빙하는 방법"
module: "architecture"
quizzes:
  - question: "파일 업로드 시 클라이언트가 S3로 직접 업로드하도록 'Presigned URL'을 사용하는 가장 큰 이유는?"
    options:
      - "S3의 보안 정책을 우회하기 위해"
      - "앱 서버가 대용량 파일 트래픽을 직접 처리하지 않아도 되어 서버 부하와 비용을 줄일 수 있다."
      - "파일 메타데이터를 저장하지 않아도 된다."
      - "파일 변환을 자동으로 처리해준다."
    answer: 1
    explanation: "Presigned URL을 사용하면 클라이언트가 S3와 직접 통신하므로, 앱 서버는 대용량 파일을 프록시하지 않아도 되어 대역폭 병목에서 해방됩니다."

  - question: "대용량 파일 업로드 시 '멀티파트 업로드(Multipart Upload)'를 사용하는 주요 이점은?"
    options:
      - "파일 업로드 속도가 느려진다."
      - "파일을 여러 파트로 나눠 업로드하므로, 실패한 파트만 재시도하고 중단 후 재개(Resume)가 가능하다."
      - "파일 크기가 자동으로 압축된다."
      - "클라이언트 권한 검증이 필요 없다."
    answer: 1
    explanation: "멀티파트 업로드는 파일을 조각으로 나눠 업로드하므로, 네트워크 문제 발생 시 처음부터 다시 업로드할 필요 없이 실패한 파트만 재시도하면 됩니다."

  - question: "CDN 캐시 무효화(Invalidation) 비용을 줄이기 위한 가장 효과적인 파일 명명(Naming) 전략은?"
    options:
      - "모든 파일에 같은 이름을 사용한다."
      - "파일 내용의 해시(Hash) 값을 파일명에 포함하여 콘텐츠가 변경되면 파일명도 바뀌게 한다. (Immutable Naming)"
      - "파일 버전을 쿼리 파라미터로만 관리한다."
      - "캐시 TTL을 0으로 설정한다."
    answer: 1
    explanation: "파일명에 콘텐츠 해시를 포함하면 파일 내용이 바뀔 때 경로도 바뀌므로, CDN 캐시를 명시적으로 무효화(Purge)할 필요가 거의 없어지고 강력한 장기 캐시 설정이 가능해집니다."

  - question: "비공개 파일을 CDN을 통해 서빙할 때 권한을 제어하는 일반적인 방법은?"
    options:
      - "S3 버킷을 Public으로 설정한다."
      - "백엔드에서 권한 확인 후 CDN Signed URL 또는 Signed Cookie를 발급한다."
      - "파일 경로를 길고 복잡하게 만든다."
      - "모든 파일에 비밀번호를 건다."
    answer: 1
    explanation: "비공개 파일은 Public 접근이 불가능해야 합니다. 백엔드에서 사용자 권한을 확인한 뒤, 짧은 만료 시간을 가진 Signed URL을 발급하여 CDN을 통해 안전하게 제공합니다."

  - question: "업로드된 파일의 악성 코드 여부를 검증하기 위한 가장 안전한 처리 시점은?"
    options:
      - "클라이언트(웹 브라우저)에서 업로드 직전에 검사한다."
      - "업로드 완료 S3 이벤트를 트리거로 비동기 워커에서 스캔하고, 스캔 완료 전까지 서빙 상태(status)를 제한한다."
      - "업로드를 요청하는 API에서 동기적으로 스캔한다."
      - "다운로드 요청 시마다 스캔한다."
    answer: 1
    explanation: "클라이언트 측 검사는 우회 가능하고, 동기 스캔은 업로드 지연을 유발합니다. S3 업로드 완료 이벤트를 받아 비동기 워커에서 스캔하고, 결과(감염/정상)에 따라 파일 상태를 업데이트하는 것이 일반적입니다."
study_order: 456
---

## 이 글에서 얻는 것

- 파일 업로드/서빙을 “백엔드가 프록시”하는 대신, **Direct-to-Object Storage(S3) + CDN**으로 안전하고 빠르게 설계할 수 있습니다.
- Presigned URL, 멀티파트 업로드, 캐시 정책(Cache-Control) 등 핵심 구성 요소를 요구사항(보안/권한/비용/성능)에 맞춰 선택할 수 있습니다.
- 운영에서 자주 터지는 문제(권한 우회, 악성 파일, 대용량 업로드 실패, 캐시 무효화 비용)를 설계 단계에서 예방할 수 있습니다.

## 0) 요구사항을 먼저 정리하자

파일 시스템 설계는 “업로드/다운로드” 두 가지만 있는 게 아니라 다음을 포함합니다.

- 접근 제어: 누가 올리고/누가 볼 수 있는가(공개/비공개)
- 대용량: 수십~수백 MB, 업로드 실패/재시도/재개(resume)
- 변환: 이미지 리사이즈/썸네일/동영상 트랜스코딩
- 보안: 악성 파일/피싱/권한 우회, 민감 데이터 노출 방지
- 비용: 트래픽을 앱 서버로 통과시키지 않기(CDN/오리진 비용)

## 1) 기본 아키텍처: “서버를 통과하지 않는다”

### 업로드(Direct upload)

1) 클라이언트가 백엔드에 “업로드 요청”  
2) 백엔드가 권한 확인 후 Presigned URL 발급  
3) 클라이언트가 S3로 직접 업로드  
4) 업로드 완료 후 메타데이터를 백엔드에 등록(또는 S3 이벤트로 후처리)  

### 서빙(Deliver via CDN)

- CloudFront/Cloudflare 같은 CDN이 S3 오리진에서 파일을 가져와 캐시
- 공개 파일이면 캐시 정책으로 성능/비용 최적화
- 비공개 파일이면 Signed URL/Signed Cookie로 접근 제어

핵심 효과:

- 앱 서버는 트래픽/대역폭 병목에서 해방됩니다.
- 업로드/다운로드는 CDN/S3가 처리하고, 앱은 “권한/메타데이터/워크플로”에 집중합니다.

## 2) 업로드 설계: Presigned URL vs 멀티파트

### 2-1) Presigned PUT(단순 업로드)

- 작은 파일/중간 크기 파일에 적합
- 만료 시간을 짧게(예: 1~10분) 주고, 업로드 대상 key를 서버가 통제합니다

### 2-2) 멀티파트 업로드(대용량/재개)

- 파일을 파트로 나눠 업로드하고, 실패한 파트만 재시도 가능
- 업로드 중단/재개가 쉬워 대용량에 적합
- 미완료 multipart 정리(수명/정리 작업)를 운영 정책으로 둬야 합니다

## 3) 파일 키(key) 설계: 경로가 곧 권한/운영 난이도다

권장:

- 사용자 입력 파일명은 그대로 key로 쓰지 않기(충돌/보안/인코딩 이슈)
- 서버가 생성한 안정적인 key 사용(예: UUID)
- 네임스페이스를 명확히(테넌트/유저/도메인)

예:

- `uploads/{tenantId}/{userId}/{fileId}/original`
- `uploads/{tenantId}/{userId}/{fileId}/thumb_256.webp`

## 4) 메타데이터(DB): 파일의 ‘상태’를 관리한다

S3에는 파일이 있고, DB에는 “이 파일이 무엇인지”가 있습니다.

예시 컬럼:

- `file_id`, `owner_id`, `s3_key`, `content_type`, `size`, `checksum`
- `status`: UPLOADING → UPLOADED → SCANNED → AVAILABLE
- `visibility`: PUBLIC/PRIVATE
- `created_at`, `expire_at`(선택)

이렇게 하면:

- 업로드가 끝났는지/스캔이 끝났는지/서빙 가능한지
- 권한 체크를 어디서 할지

가 명확해집니다.

## 5) 보안: “업로드가 제일 위험하다”

최소한 아래는 반드시 고려합니다.

- Content-Type/크기 제한(클라이언트 주장만 믿지 말고 서버/스캔 단계에서 확인)
- CORS 정책 최소화(허용 오리진/메서드/헤더 제한)
- Presigned URL 만료 짧게 + 한 번 쓰고 끝내는 흐름(업로드 완료 후 상태 전환)
- 악성 파일 스캔(버킷 이벤트 → 워커/Lambda → 결과에 따라 격리)
- 비공개 파일은 public ACL 금지, “권한 있는 경우에만” Signed URL 발급

## 6) CDN 캐시 전략: “무효화”보다 “버전”이 싸다

정적 파일은 캐시가 핵심입니다.

- 파일명을 콘텐츠 해시 기반으로 만들면(immutable) `Cache-Control: public, max-age=31536000, immutable` 같은 강한 캐시가 가능합니다.
- 파일이 바뀌면 파일명이 바뀌므로 “캐시 무효화”를 거의 하지 않아도 됩니다.

반대로, 파일명이 고정인데 내용이 바뀌면:

- CDN invalidation(퍼지) 비용/지연이 생기고 운영이 어려워집니다.

## 7) 비공개 파일 서빙: Signed URL / Signed Cookie

공개 파일과 달리 “누가 볼 수 있는지”가 중요합니다.

- 백엔드에서 권한 체크 후 CDN Signed URL을 발급(짧은 만료)
- 또는 Signed Cookie로 일정 시간 접근 허용(여러 파일 접근에 편함)

실무 팁:

- 만료가 너무 길면 유출 사고가 커집니다.
- URL 공유가 가능한 UX라면 만료/재발급 흐름을 명확히 해야 합니다.

## 8) 변환/썸네일: 동기 처리 금지(대부분)

업로드 요청에서 이미지 리사이즈/동영상 트랜스코딩을 동기로 하면,
요청 지연/타임아웃/리소스 고갈이 쉽게 발생합니다.

권장 흐름:

- 업로드 완료 이벤트 → 비동기 워커 → 파생 파일 생성 → 상태 업데이트

## 연습(추천)

- “업로드 요청 → presigned 발급 → S3 업로드 → 완료 콜백 → 메타데이터 저장” 흐름을 최소 구현해보기
- 대용량 파일을 멀티파트로 올리고, 실패 파트 재시도가 동작하는지 확인해보기
- 공개 파일은 장기 캐시(해시 파일명)로, 비공개 파일은 Signed URL로 서빙하는 정책을 나눠 설계해보기
